<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="style.css">
    </head>
    <body onload="init()">
        <h1 class="main_title">Path tracer</h1>
        <p class="subtitle">Web-based path tracer</p>
        <hr>
        <br>
        <div id="main_content">
            <div>
                <div id="parameters"></div>
                <hr>
                <div class="center flex-column">
                    <div id="bottom_parameters"></div>
                    <button onclick="render()">Render</button>
                    <p id="progress"></p>
                </div>
            </div>
            <canvas id="canvas" width="800" height="800"></canvas>
        </div>
        <hr>
        <div class="explanations">
            <p>This is a very simple path tracer implemented purely in javascript.</p>
            <p>For now it is very limited and not well optimized. Numerous new features are planned. For now it has the following features : </p>
            <ul>
                <li>Handles spheres and triangle rendering, with the feature to load any triangulated mesh</li>
                <li>User-defined number of samples per pixels (for now the samples in each pixel have random position)</li>
                <li>Camera with modifiable position and FOV</li>
                <li>Usage of a <a href="https://en.wikipedia.org/wiki/Bounding_volume_hierarchy">Bounding Volume Hierarchie</a> to improve the performance</li>
                <li>Materials including</li>
                <ul>
                    <li>Lambertian diffuse</li>
                    <li>Reflections, with granularity</li>
                    <li>Refraction, with total internal reflection</li>
                </ul>
            </ul>
        </div>
    </body>
    <script src="js/ModelHelper.js"></script>
    <script type="module">
        import Slider from "./js/ui/slider.js"
        import Tabs from "./js/ui/tabs.js"
        import Camera from "./js/camera.js"
        import {Ray, Vec3, Color} from "./js/primitives.js"
        import {Sphere, Triangle} from "./js/objects.js"
        import {Material, LambertianDiffuse, Reflect, Refract} from "./js/materials.js"
        document.Slider = Slider
        document.Tabs   = Tabs
        document.Camera = Camera
        document.Ray = Ray
        document.Vec3 = Vec3
        document.Color = Color
        document.Sphere = Sphere
        document.Triangle = Triangle
        document.Material = Material
        document.LambertianDiffuse = LambertianDiffuse
        document.Reflect = Reflect
        document.Refract = Refract
    </script>
    <script>
        function init(){
            Slider   = document.Slider
            Tabs     = document.Tabs
            Camera   = document.Camera
            Ray      = document.Ray
            Vec3     = document.Vec3
            Color    = document.Color
            Sphere   = document.Sphere
            Triangle = document.Triangle
            Material = document.Material
            LambertianDiffuse = document.LambertianDiffuse
            Reflect = document.Reflect
            Refract = document.Refract

            document.global_params = {
                samples_per_pixel: 5,
                nb_workers:        12,
                chunk_size:        100,
                camera:{
                    fov: 45,
                    x:0,
                    y:0,
                    z:0
                },
                pixels_computed: 0
            }

            let tabs = new Tabs(document.getElementById("parameters"), "main_tabs", ["Camera", "Objects"], "Camera")
            tabs.setContent("Camera", `
                <p>Position</p>
                <div id="camera_position"></div>
                <p>Lens</p>
                <div id="camera_others"></div>
            `)
            tabs.setContent("Objects", `
                <p>-- Tab under construction --</p>
            `)

            new Slider("camera_position", "X", 0,  val=>document.global_params.camera.x=val, -20, 20, 1)
            new Slider("camera_position", "Y", 0,  val=>document.global_params.camera.y=val, -20, 20, 1)
            new Slider("camera_position", "Z", 0,  val=>document.global_params.camera.z=val, -20, 20)
            new Slider("camera_others", "Field of view", 45, val=>document.global_params.camera.fov=val, 5, 170)
            new Slider("bottom_parameters", "Samples per pixel", 25,  val=>document.global_params.samples_per_pixel=val, 5, 100, 1, 0)
        }
 
        function render(){
            const params = document.global_params
            const canvas    = document.getElementById("canvas")
            const ctx       = canvas.getContext("2d")
            const imageData = ctx.createImageData(canvas.width, canvas.height)
            const camera = new Camera(canvas.width/canvas.height, params.camera.fov, Vec3.new(params.camera.x, params.camera.y, params.camera.z))

            ctx.clearRect(0, 0, canvas.width, canvas.height)

            let workers = []
            for(let i=0; i<params.nb_workers; i++){
                workers.push(new Worker("js/worker.js", {type: "module"}))
            }

            ModelHelper.loadWavefront("teapot/teapot_smooth.obj").then( teapot => {

                let diffuse = new Material(new LambertianDiffuse(), Color.new(0.8, 0.4, 0.3, 1))
                let mirror  = new Material(new Reflect(0), Color.new(0.4, 0.8, 0.3, 1))
                let mirror2  = new Material(new Reflect(0.2), Color.new(0.4, 0.8, 0.3, 1))
                let refract = new Material(new Refract(1, 1.5), Color.new(0.8, 0.8, 1, 1))

                let obj = [
                    new Sphere( Vec3.new(0,   -80.98, -4), 80, diffuse),
                    new Sphere( Vec3.new(1.2, 1.2, -5), 0.5, mirror2),
                    new Sphere( Vec3.new(-1.2,  1.2, -5), 0.5, mirror2),

                    
                    new Sphere( Vec3.new(-0.6, 1.5, -5), 0.1, diffuse),
                    new Sphere( Vec3.new(-0.4, 1.5, -5), 0.1, diffuse),
                    new Sphere( Vec3.new(-0.2, 1.5, -5), 0.1, diffuse),
                    new Sphere( Vec3.new(0.0, 1.5, -5), 0.1, diffuse),
                    new Sphere( Vec3.new(0.2, 1.5, -5), 0.1, diffuse),
                    new Sphere( Vec3.new(0.4, 1.5, -5), 0.1, diffuse),
                    new Sphere( Vec3.new(0.6, 1.5, -5), 0.1, diffuse),

                    new Sphere( Vec3.new(-0.3, -0.88, -2.7), 0.1, diffuse),
                    new Sphere( Vec3.new(0.3, -0.88, -2.7), 0.1, diffuse),

                    new Sphere( Vec3.new(-0.3, -0.68, -2.7), 0.1, diffuse),
                    new Sphere( Vec3.new(0.3, -0.68, -2.7), 0.1, diffuse),

                    new Sphere( Vec3.new(-0.3, -0.48, -2.7), 0.1, diffuse),
                    new Sphere( Vec3.new(0.3, -0.48, -2.7), 0.1, diffuse),

                    new Sphere( Vec3.new(-0.3, -0.28, -2.7), 0.1, diffuse),
                    new Sphere( Vec3.new(0.3, -0.28, -2.7), 0.1, diffuse),


                    new Sphere( Vec3.new(-0.7, -0.86, -3), 0.15, refract),
                    new Sphere( Vec3.new(0.7, -0.86, -3), 0.15, refract),

                    new Sphere( Vec3.new(-0.7, -0.56, -3), 0.15, refract),
                    new Sphere( Vec3.new(0.7, -0.56, -3), 0.15, refract),
                ]
                for(let i=0; i<teapot.faces.length; i++){
                    let p1 = Vec3.new(
                        parseFloat(teapot.vertices[teapot.faces[i].vertices[0]][0])/2, 
                        parseFloat(teapot.vertices[teapot.faces[i].vertices[0]][1])/2-1, 
                        parseFloat(teapot.vertices[teapot.faces[i].vertices[0]][2])/2-4
                    )
                    let p2 = Vec3.new(
                        parseFloat(teapot.vertices[teapot.faces[i].vertices[1]][0])/2, 
                        parseFloat(teapot.vertices[teapot.faces[i].vertices[1]][1])/2-1, 
                        parseFloat(teapot.vertices[teapot.faces[i].vertices[1]][2])/2-4
                    )
                    let p3 = Vec3.new(
                        parseFloat(teapot.vertices[teapot.faces[i].vertices[2]][0])/2, 
                        parseFloat(teapot.vertices[teapot.faces[i].vertices[2]][1])/2-1, 
                        parseFloat(teapot.vertices[teapot.faces[i].vertices[2]][2])/2-4
                    )
                    let p1_n = Vec3.new(
                        parseFloat(teapot.normals[teapot.faces[i].normals[0]][0]), 
                        parseFloat(teapot.normals[teapot.faces[i].normals[0]][1]), 
                        parseFloat(teapot.normals[teapot.faces[i].normals[0]][2])
                    )
                    let p2_n = Vec3.new(
                        parseFloat(teapot.normals[teapot.faces[i].normals[1]][0]), 
                        parseFloat(teapot.normals[teapot.faces[i].normals[1]][1]), 
                        parseFloat(teapot.normals[teapot.faces[i].normals[1]][2])
                    )
                    let p3_n = Vec3.new(
                        parseFloat(teapot.normals[teapot.faces[i].normals[2]][0]), 
                        parseFloat(teapot.normals[teapot.faces[i].normals[2]][1]), 
                        parseFloat(teapot.normals[teapot.faces[i].normals[2]][2])
                    )
                    obj.push(new Triangle(p1, p2, p3, mirror, p1_n, p2_n, p3_n))
                }

                workers.forEach( w => {
                    w.onmessage = onWorkerMessage(w)
                    w.postMessage({msg:"init", objs:obj, camera:camera})
                    let next = getNextChunk()
                    if(next != null){
                        w.postMessage(next)
                    }
                })
            })
        }

        function onWorkerMessage(w){
            return e => {
                const result = e.data
                if(result.msg == "finished"){
                    const imageData = new ImageData(result.imageData, result.width, result.height)
                    canvas.getContext("2d").putImageData(imageData, result.posX, result.posY)
                    const next = getNextChunk()
                    if(next != null){
                        w.postMessage(next)
                    }
                }else{
                    document.global_params.pixels_computed += result.progress
                    const nb_pixels = document.getElementById("canvas").width*document.getElementById("canvas").height
                    const progress = 100*document.global_params.pixels_computed/nb_pixels
                    document.getElementById("progress").innerHTML = progress.toFixed(2)+" %"
                }
            }
        }

        function getNextChunk(){
            if(document.global_params.currentChunk === undefined){
                document.global_params.currentChunk = 0
            }

            const chunk_size = document.global_params.chunk_size

            const canvas_width  = document.getElementById("canvas").width
            const canvas_height = document.getElementById("canvas").height
            const nb_chunks_width  = canvas_width  / chunk_size
            const nb_chunks_height = canvas_height / chunk_size
            const indexX = document.global_params.currentChunk%nb_chunks_width
            const indexY = Math.floor(document.global_params.currentChunk/nb_chunks_height)

            const startX = indexX*chunk_size
            const startY = indexY*chunk_size
            const chunk_width  = Math.min(chunk_size, canvas_width  - startX)
            const chunk_height = Math.min(chunk_size, canvas_height - startY)

            if(chunk_height <= 0){
                return null
            }

            document.global_params.currentChunk++
            //console.log(`Start chunk (${indexX};${indexY}) at (${indexX*chunk_size};${indexY*chunk_size}) with width ${chunk_width}, height ${chunk_height}`)
            return {
                msg: "start",
                img_width:  canvas_width,
                img_height: canvas_height,
                chunk_width:  chunk_width,
                chunk_height: chunk_height,
                startX: startX,
                startY: startY,
                samples_per_pixel: document.global_params.samples_per_pixel,
            }
        }
    </script>  
</html>